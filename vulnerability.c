// The following code in C language contains some vulnerabilities. 
// Analyze the code, report in the code as comments the vulnerabilities 
// you have found and explain why these are vulnerabilities.


#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#define PASSWORD "ABCD1234!"
/*You need not worry about other include statements if at all any are missing */

// Vulnerability alert: The PASSWORD macro stores a password in plaintext in the source code, which is a bad security practice.

void func1()
{
    char * data;
    // Vulnerability!!!
    // Use of a non-standard function ALLOCA, which seems to be an attempt to use alloca. The use of alloca is risky as it can lead to stack 
    // overflow. The alloca function is a function that allocates memory on the stack, rather than on the heap like malloc and calloc. The
    // stack has a limited size, which is usually much smaller than the heap. Large allocations with alloca can quickly exhaust the stack,
    // leading to stack overflow errors.
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    memset(dataBuffer, 'A', 100-1);
    dataBuffer[100-1] = '\0'; 
    // Vunerability!!!
    // Pointer arithmetic data = dataBuffer - 8.
    // Pointer arithmetic that causes 'data' to point before the allocated 'dataBuffer'
    data = dataBuffer - 8; 
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        // Vulnerability!!!
        // Buffer underflow in 'data' can lead to overwrite of adjacent stack data.
        strcpy(data, source); 
        if(data != NULL) 
        {
            printf("%s\n", data);
        }
    }
}

void func2()
{
    char * data;
    data = NULL;
    data = (char *)calloc(100, sizeof(char));
    // Vulnerability!!!
    // No bounds check before strcpy which can potentially lead to buffer overflow if "A String" is replaced by a 
    // longer string that exceeds the allocated buffer size.
    strcpy(data, "A String");
    if(data != NULL) 
    {
        printf("%s\n", data);
    }
    // Vulnerabnility!!!
    // The variable 'data' should be freed.
}

void func3()
{
    char * password;
    char passwordBuffer[100] = "";
    password = passwordBuffer;
    // Vulnerability:
    // Storing passwords in plaintext within the source code is a critical security vulnerability. 
    // It exposes sensitive information and should be avoided.
    // An attacker with access to the source code or compiled binary can retrieve the password.
    strcpy(password, PASSWORD);
    {
        HANDLE pHandle;
        char * username = "User";
        char * domain = "Domain";
        /* Let's say LogonUserA is a custon authentication function*/
        if (LogonUserA(
                    username,
                    domain,
                    password,
                    &pHandle) != 0)
        {
            printf("User logged in successfully.\n");
            CloseHandle(pHandle);
        }
        else
        {
            printf("Unable to login.\n");
        }
    }
}

static void func4()
{
    char * data;
    data = NULL;
    data = (char *)calloc(20, sizeof(char));
    if (data != NULL)
    {
        // Vulnerability!!!
        // No bounds check
        strcpy(data, "Initialize");
        // Redundant check
        if(data != NULL) 
        {
            printf("%s\n", data);
        }
        free(data);
    }
}

void func5() 
{   
    int i = 0;
    do
    {
        printf("%d\n", i);
        i = (i + 1) % 256;
    // Vulnerability:
    // The while loop is the source of vulnerability
    // Due to the modulo operation and the condition check, the loop will never terminate.
    // The infinite loop causes the program to enter an infinite loop, potentially leading to a denial of service if used in a critical application.
    } while(i >= 0);
}

void func6()
{
    char dataBuffer[100] = "";
    char * data = dataBuffer;
    printf("Please enter a string: ");
    // Vulnerability!!!
    // Misuse of fgets() function. The fgets function returns NULL on error, not a negative number. The comparison should be against NULL.
    // The incorrect check will not catch an error returned by fgets, leading to potential undefined behavior.
    
    if (fgets(data, 100, stdin) < 0)
    {
        printf("fgets failed!\n");
        exit(1);
    }
    if(data != NULL) 
    {
        printf("%s\n", data);
    }

}

void func7()
{
    char * data;
    data = "Fortify";
    data = NULL;
    // Vulnerability!!!
    // Dereferencing a NULL pointer is undefined behavior and can cause the program to crash.
    // This would lead to a crash (segmentation fault) on most systems.
    printf("%s\n", data);
}

int main(int argc, char * argv[])
{
    printf("Calling func1\n");
    func1();

    printf("Calling func2\n");
    func2();

    printf("Calling func3\n");
    func3();

    printf("Calling func4\n");
    func4();

    printf("Calling func5\n");
    func5();

    printf("Calling func6\n");
    func6();

    printf("Calling func7\n");
    func7();

    return 0;
}
